# s = [1,2,[{11:111},123,{1,2},(1,-2,3)]]
# print(s[2][0][11])
# Обращаемся к ключу

# for i in range(10):
#     print(i, (lambda u: u * u)(i))


# lambda функция делает то, что после запятой.
# Если нам лень писать функцию - просто делаем ее лямбдой и все


# quadrant = (lambda u: u * u)
# for i in range(10):
#     print(quadrant(i))


# s = (lambda x,y, *args, **kwargs: x * y)
# print(s(2,3,4))


# s = (lambda x,y = 3, *args, **kwargs: x * y)
# print(s(2, y = 5))


# full_name = lambda f,s: f'Full_name:{f.title()},{s.title()}'
# print(full_name('guido','van rossum'))


# gnirts = lambda s: s.lower()[::-1]
# print(gnirts('abcABC_321'))


# gnirts = lambda s: s.swapcase()[::-1]
# print(gnirts('abcABC_321'))


# # сначала четные, затем нечетные числа
# lst = [0,1,2,3,4,5,6,7,8,9]
# print(sorted(lst, key = lambda x: (x % 2)))


# s = [0,11,22,3,456,51,63,77,8,9]
# print(sorted(s, key = lambda x: (x % 2, x)))


# В первом коде используется только ключ, определенный с помощью лямбда-функции `(x % 2)`.
# Этот ключ группирует элементы списка по четности: все четные числа будут иметь ключ 0,
# все нечетные числа будут иметь ключ 1. Поскольку ключи имеют только два возможных значения,
# четные числа будут отображаться перед нечетными числами в отсортированном списке.

# Во втором коде используются два ключа для сортировки элементов списка: `(x % 2, x)`.
# Вначале элементы группируются по их четности, как и в первом коде. Затем, внутри каждой группы,
# элементы сортируются по их собственным значениям. Например, сначала отсортированными будут все четные числа,
# а затем все нечетные числа, при сохранении исходного порядка внутри каждой группы.


# s = ['abc', 'XYZ', 'CDe', 'All', 'you']
# print(sorted(s, key = lambda y: y.lower()))
# # Данная функция сортирует список `s` в алфавитном порядке, но игнорирует регистр букв.
# # Это достигается с помощью ключа `key = lambda y: y.lower()`. Внутри функции `lambda`
# # каждый элемент списка приводится к нижнему регистру с помощью метода `lower()`, а затем происходит сортировка.


# # Ближайшее число к иксу
# lst = [0,11,22,3,456,51,63,72,8,9]
# x = 15
# print(min(lst, key = lambda y: abs(y - x)))


# lst = (0,1,2,3,4,5,6,7,8,9)
# print(list(filter(lambda x: x % 3 != 0, lst)))


# lst = [0,1,2,3,4,5,6,7,8,9,0,16]
# x = 17
# print(min(lst, key = lambda y: abs(y-x)))


# # summa
# lst = [123, 456, 789, 9876, 32345]
# print(list(map(lambda x: sum(map(int, list(str(x)))), lst)))
# # 1. сначала каждое число переводится в стринг. Затем функцией лист он разбивает ее на ячейки.
# # Потом функцией инт переводит опять в число!
# # Таким образом мы имеет разбитое по ячейкам число.


# # по последнему элементу в обратном порядке
# lst = [123, 456, 789, 9876, 32345]
# print(sorted(lst, key=lambda x: -int(str(x)[-1])))


# # по последнему элементу по возрастанию
# lst = [123, 456, 789, 9876, 32345]
# print(sorted(lst, key=lambda x: int(str(x)[-1])))


# # Тернарные операции
# x,y = 1, 2
# maxi = x if x>=y else y
# print(maxi)


# # if for and while нельзя в lambda (for x in нельзя)

# lower = (lambda x,y: x if x<= y else y)
# lower(3,4)


# lower = (lambda x,y: x if x<= y else y)
# lower(3,5)


# print((lambda x,y: x if x <=y else y)(10,8))


# dohod = int(input())
# nalog = (lambda x: x * 0.13 if x <= 5000000 else 5000000 * 0.13 + 0.15 * (x - 5000000))
# print(nalog(dohod))


# s = [('b',500),('c',300),('x',500),('e',100),('e',700)]
# s_s = sorted(s, key = lambda x: (-x[1], x[0]))
# for name, bonus in s_s:
#     print(name, bonus)


# Сначала отсортируй по второму элементу в порядке обратном - от большего к меньшему.
# Затем, если втретятся два одинаковых числа, то отсортируй их в прямом порядке алфавита (от А до Я).


# s = [('b',500),('c',700),('d',760),('e',800),('h',1000),('l',1200)]
# s_s = sorted(s, key = lambda x: (x[0], x[1]))
# for name, bonus in s_s:
#     print(name, bonus)


# Сначала отсортируй по первому элементу в прямом порядке - от А до Я.
# Затем, если втретятся две одинаковых буквы, то отсортируй значения от меньшего к большему.


# dct = dict.fromkeys([0,True,'a','b',(1,2),1],0)
# # Метод `fromkeys()` класса `dict` создает новый словарь с ключами из указанной итерируемой последовательности и значениями,
# # которые задаются одним и тем же значением по умолчанию.
# # т.е. у 'a' сейчас значение 0.
# # Ключами в словорях могуть быть только неизменяемые объекты (числа, строки, кортежи, True, False, None, замороженные словари),
# # а значениями все, что угодно.
# dct.update({'a':123})
# print(dct)


# # Космос какой-то:
# a = {True:abs, False:(lambda x:x * x), 3:{1,2,3}, '1':[1,2], 'Город':'Санкт-Петербург'}
# print(a[True](-123))
# print(a[False](5))


# student = {0: {'name': 'Иванов', 'age': 23},
#            1: {'name': 'Петров', 'age': '23'},
#            2: {'name': 'Сидоров', 'adress': 'SPb'}}
# # Обращаемся к одному элементу
# print(student[1]['name'])
# # items выдает нам пары
# for key, value in student.items():
#     for k, v in value.items():
#         print(k, v)


# Задача: дан словарь dct с не более чем двумя уровнями вложенности.
# Введите ключ x и напечатайте значения всех словарей, у которых ключ совпадает с x:
dct = {1: 123, 2: 234, 3: {1: 111, 2: 222}, 4: {1: 'abc', 2: 'def'}}
x = int(input('Введите число: '))

for i in dct.values():
    if type(i) is dict:
        if x in i:
            print(i[x], end=' ')
    elif i == x:
        print(i, end=' ')
